// Code generated by eddwise, DO NOT EDIT.

package filotto

import (
	"errors"

	"github.com/exelr/eddwise"
)

var _ eddwise.ImplChannel = (*Filotto)(nil)

type FilottoContext interface {
	eddwise.Context
	GetChannel() *Filotto
}

type FilottoDefaultContext struct {
	eddwise.Context
	channel *Filotto
}

func (ctx *FilottoDefaultContext) GetChannel() *Filotto {
	return ctx.channel
}

type FilottoRecv interface {
	OnPlayerMove(FilottoContext, *PlayerMove) error

	OnQueueRequest(FilottoContext, *QueueRequest) error
}

type Filotto struct {
	server *eddwise.Server
	recv   FilottoRecv
}

func (ch *Filotto) Name() string {
	return "Filotto"
}

func (ch *Filotto) Bind(server *eddwise.Server) error {
	ch.server = server
	return nil
}

func (ch *Filotto) SetReceiver(chr interface{}) {
	ch.recv = chr.(FilottoRecv)
}

func (ch *Filotto) GetServer() *eddwise.Server {
	return ch.server
}

func (ch *Filotto) Route(ctx eddwise.Context, evt *eddwise.Event) error {
	var ctx2 = &FilottoDefaultContext{
		Context: ctx,
		channel: ch,
	}
	switch evt.Name {
	default:
		return eddwise.ErrMissingServerHandler(evt.Channel, evt.Name)

	case "PlayerMove":
		var msg = &PlayerMove{}
		if err := ch.server.Serializer.Deserialize(evt.Body, msg); err != nil {
			return err
		}
		return ch.recv.OnPlayerMove(ctx2, msg)

	case "QueueRequest":
		var msg = &QueueRequest{}
		if err := ch.server.Serializer.Deserialize(evt.Body, msg); err != nil {
			return err
		}
		return ch.recv.OnQueueRequest(ctx2, msg)

	}
}

func (ch *Filotto) OnPlayerMove(FilottoContext, *PlayerMove) error {
	return errors.New("event 'PlayerMove' is not handled on server")
}

func (ch *Filotto) OnQueueRequest(FilottoContext, *QueueRequest) error {
	return errors.New("event 'QueueRequest' is not handled on server")
}

func (ch *Filotto) SendMatchEnds(client *eddwise.Client, msg *MatchEnds) error {
	return client.Send(ch.Name(), "MatchEnds", msg)
}

func (ch *Filotto) SendMatchStarts(client *eddwise.Client, msg *MatchStarts) error {
	return client.Send(ch.Name(), "MatchStarts", msg)
}

func (ch *Filotto) SendPlayerMove(client *eddwise.Client, msg *PlayerMove) error {
	return client.Send(ch.Name(), "PlayerMove", msg)
}

func (ch *Filotto) SendWelcome(client *eddwise.Client, msg *Welcome) error {
	return client.Send(ch.Name(), "Welcome", msg)
}

func (ch *Filotto) BroadcastMatchEnds(clients []*eddwise.Client, msg *MatchEnds) error {
	return ch.server.Broadcast(ch.Name(), "MatchEnds", msg, clients)
}

func (ch *Filotto) BroadcastMatchStarts(clients []*eddwise.Client, msg *MatchStarts) error {
	return ch.server.Broadcast(ch.Name(), "MatchStarts", msg, clients)
}

func (ch *Filotto) BroadcastPlayerMove(clients []*eddwise.Client, msg *PlayerMove) error {
	return ch.server.Broadcast(ch.Name(), "PlayerMove", msg, clients)
}

func (ch *Filotto) BroadcastWelcome(clients []*eddwise.Client, msg *Welcome) error {
	return ch.server.Broadcast(ch.Name(), "Welcome", msg, clients)
}

// Event structures

type Welcome struct {
	You Player `json:"You"`
}

type Player struct {
	Id   uint64 `json:"Id"`
	Name string `json:"Name"`
}

type QueueRequest struct {
}

type MatchStarts struct {
	Adversary *Player `json:"Adversary,omitempty"`
	FirstMove bool    `json:"FirstMove"`
	Columns   uint64  `json:"Columns"`
	Rows      uint64  `json:"Rows"`
}

type MatchEnds struct {
	Winner  *Player `json:"Winner,omitempty"`
	WinLine []Point `json:"WinLine"`
	Reason  string  `json:"Reason"`
}

type Point struct {
	Row    uint `json:"Row"`
	Column uint `json:"Column"`
}

type PlayerMove struct {
	Player *Player `json:"Player,omitempty"`
	Column uint    `json:"Column"`
	Row    *uint   `json:"Row,omitempty"`
}
